{"version":3,"file":"webpack.js","sources":["../../../src/config/webpack.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getSentryRelease } from '@sentry/node';\nimport { arrayify, dropUndefinedKeys, escapeStringForRegex, logger } from '@sentry/utils';\nimport { default as SentryWebpackPlugin } from '@sentry/webpack-plugin';\nimport * as chalk from 'chalk';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport {\n  BuildContext,\n  EntryPropertyObject,\n  NextConfigObject,\n  SentryWebpackPluginOptions,\n  UserSentryOptions,\n  WebpackConfigFunction,\n  WebpackConfigObject,\n  WebpackEntryProperty,\n  WebpackModuleRule,\n} from './types';\n\nexport { SentryWebpackPlugin };\n\n// TODO: merge default SentryWebpackPlugin ignore with their SentryWebpackPlugin ignore or ignoreFile\n// TODO: merge default SentryWebpackPlugin include with their SentryWebpackPlugin include\n// TODO: drop merged keys from override check? `includeDefaults` option?\n\n/**\n * Construct the function which will be used as the nextjs config's `webpack` value.\n *\n * Sets:\n *   - `devtool`, to ensure high-quality sourcemaps are generated\n *   - `entry`, to include user's sentry config files (where `Sentry.init` is called) in the build\n *   - `plugins`, to add SentryWebpackPlugin\n *\n * @param userNextConfig The user's existing nextjs config, as passed to `withSentryConfig`\n * @param userSentryWebpackPluginOptions The user's SentryWebpackPlugin config, as passed to `withSentryConfig`\n * @returns The function to set as the nextjs config's `webpack` value\n */\nexport function constructWebpackConfigFunction(\n  userNextConfig: NextConfigObject = {},\n  userSentryWebpackPluginOptions: Partial<SentryWebpackPluginOptions> = {},\n  userSentryOptions: UserSentryOptions = {},\n): WebpackConfigFunction {\n  // Will be called by nextjs and passed its default webpack configuration and context data about the build (whether\n  // we're building server or client, whether we're in dev, what version of webpack we're using, etc). Note that\n  // `incomingConfig` and `buildContext` are referred to as `config` and `options` in the nextjs docs.\n  return function newWebpackFunction(\n    incomingConfig: WebpackConfigObject,\n    buildContext: BuildContext,\n  ): WebpackConfigObject {\n    const { isServer, dev: isDev, dir: projectDir } = buildContext;\n    let newConfig = { ...incomingConfig };\n\n    // if user has custom webpack config (which always takes the form of a function), run it so we have actual values to\n    // work with\n    if ('webpack' in userNextConfig && typeof userNextConfig.webpack === 'function') {\n      newConfig = userNextConfig.webpack(newConfig, buildContext);\n    }\n\n    if (isServer) {\n      newConfig.module = {\n        ...newConfig.module,\n        rules: [\n          ...(newConfig.module?.rules || []),\n          {\n            test: /sentry\\.server\\.config\\.(jsx?|tsx?)/,\n            use: [\n              {\n                // Support non-default output directories by making the output path (easy to get here at build-time)\n                // available to the server SDK's default `RewriteFrames` instance (which needs it at runtime), by\n                // injecting code to attach it to `global`.\n                loader: path.resolve(__dirname, 'loaders/prefixLoader.js'),\n                options: {\n                  distDir: userNextConfig.distDir || '.next',\n                },\n              },\n            ],\n          },\n        ],\n      };\n\n      if (userSentryOptions.experiments?.autoWrapDataFetchers) {\n        const pagesDir = newConfig.resolve?.alias?.['private-next-pages'] as string;\n\n        newConfig.module.rules.push({\n          // Nextjs allows the `pages` folder to optionally live inside a `src` folder\n          test: new RegExp(`${escapeStringForRegex(projectDir)}(/src)?/pages/.*\\\\.(jsx?|tsx?)`),\n          use: [\n            {\n              loader: path.resolve(__dirname, 'loaders/proxyLoader.js'),\n              options: { pagesDir },\n            },\n          ],\n        });\n      }\n    }\n\n    // The SDK uses syntax (ES6 and ES6+ features like object spread) which isn't supported by older browsers. For users\n    // who want to support such browsers, `transpileClientSDK` allows them to force the SDK code to go through the same\n    // transpilation that their code goes through. We don't turn this on by default because it increases bundle size\n    // fairly massively.\n    if (!isServer && userSentryOptions?.transpileClientSDK) {\n      // Find all loaders which apply transpilation to user code\n      const transpilationRules = findTranspilationRules(newConfig.module?.rules, projectDir);\n\n      // For each matching rule, wrap its `exclude` function so that it won't exclude SDK files, even though they're in\n      // `node_modules` (which is otherwise excluded)\n      transpilationRules.forEach(rule => {\n        // All matching rules will necessarily have an `exclude` property, but this keeps TS happy\n        if (rule.exclude && typeof rule.exclude === 'function') {\n          const origExclude = rule.exclude;\n\n          const newExclude = (filepath: string): boolean => {\n            if (filepath.includes('@sentry')) {\n              // `false` in this case means \"don't exclude it\"\n              return false;\n            }\n            return origExclude(filepath);\n          };\n\n          rule.exclude = newExclude;\n        }\n      });\n    }\n\n    // Tell webpack to inject user config files (containing the two `Sentry.init()` calls) into the appropriate output\n    // bundles. Store a separate reference to the original `entry` value to avoid an infinite loop. (If we don't do\n    // this, we'll have a statement of the form `x.y = () => f(x.y)`, where one of the things `f` does is call `x.y`.\n    // Since we're setting `x.y` to be a callback (which, by definition, won't run until some time later), by the time\n    // the function runs (causing `f` to run, causing `x.y` to run), `x.y` will point to the callback itself, rather\n    // than its original value. So calling it will call the callback which will call `f` which will call `x.y` which\n    // will call the callback which will call `f` which will call `x.y`... and on and on. Theoretically this could also\n    // be fixed by using `bind`, but this is way simpler.)\n    const origEntryProperty = newConfig.entry;\n    newConfig.entry = async () => addSentryToEntryProperty(origEntryProperty, buildContext);\n\n    // Enable the Sentry plugin (which uploads source maps to Sentry when not in dev) by default\n    if (shouldEnableWebpackPlugin(buildContext, userSentryOptions)) {\n      // TODO Handle possibility that user is using `SourceMapDevToolPlugin` (see\n      // https://webpack.js.org/plugins/source-map-dev-tool-plugin/)\n\n      // TODO (v9 or v10, maybe): Remove this\n      handleSourcemapHidingOptionWarning(userSentryOptions, isServer);\n\n      // Next doesn't let you change `devtool` in dev even if you want to, so don't bother trying - see\n      // https://github.com/vercel/next.js/blob/master/errors/improper-devtool.md\n      if (!isDev) {\n        // TODO (v8): Default `hideSourceMaps` to `true`\n\n        // `hidden-source-map` produces the same sourcemaps as `source-map`, but doesn't include the `sourceMappingURL`\n        // comment at the bottom. For folks who aren't publicly hosting their sourcemaps, this is helpful because then\n        // the browser won't look for them and throw errors into the console when it can't find them. Because this is a\n        // front-end-only problem, and because `sentry-cli` handles sourcemaps more reliably with the comment than\n        // without, the option to use `hidden-source-map` only applies to the client-side build.\n        newConfig.devtool = userSentryOptions.hideSourceMaps && !isServer ? 'hidden-source-map' : 'source-map';\n      }\n\n      newConfig.plugins = newConfig.plugins || [];\n      newConfig.plugins.push(\n        new SentryWebpackPlugin(\n          getWebpackPluginOptions(buildContext, userSentryWebpackPluginOptions, userSentryOptions),\n        ),\n      );\n    }\n\n    return newConfig;\n  };\n}\n\n/**\n * Determine if this `module.rules` entry is one which will transpile user code\n *\n * @param rule The rule to check\n * @param projectDir The path to the user's project directory\n * @returns True if the rule transpiles user code, and false otherwise\n */\nfunction isMatchingRule(rule: WebpackModuleRule, projectDir: string): boolean {\n  // We want to run our SDK code through the same transformations the user's code will go through, so we test against a\n  // sample user code path\n  const samplePagePath = path.resolve(projectDir, 'pageFile.js');\n  if (rule.test && rule.test instanceof RegExp && !rule.test.test(samplePagePath)) {\n    return false;\n  }\n  if (Array.isArray(rule.include) && !rule.include.includes(projectDir)) {\n    return false;\n  }\n\n  // `rule.use` can be an object or an array of objects. For simplicity, force it to be an array.\n  const useEntries = arrayify(rule.use);\n\n  // Depending on the version of nextjs we're talking about, the loader which does the transpiling is either\n  //\n  //   'next-babel-loader' (next 10),\n  //   '/abs/path/to/node_modules/next/more/path/babel/even/more/path/loader/yet/more/path/index.js' (next 11), or\n  //   'next-swc-loader' (next 12).\n  //\n  // The next 11 option is ugly, but thankfully 'next', 'babel', and 'loader' do appear in it in the same order as in\n  // 'next-babel-loader', so we can use the same regex to test for both.\n  if (!useEntries.some(entry => entry?.loader && new RegExp('next.*(babel|swc).*loader').test(entry.loader))) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Find all rules in `module.rules` which transpile user code.\n *\n * @param rules The `module.rules` value\n * @param projectDir The path to the user's project directory\n * @returns An array of matching rules\n */\nfunction findTranspilationRules(rules: WebpackModuleRule[] | undefined, projectDir: string): WebpackModuleRule[] {\n  if (!rules) {\n    return [];\n  }\n\n  const matchingRules: WebpackModuleRule[] = [];\n\n  // Each entry in `module.rules` is either a rule in and of itself or an object with a `oneOf` property, whose value is\n  // an array of rules\n  rules.forEach(rule => {\n    // if (rule.oneOf) {\n    if (isMatchingRule(rule, projectDir)) {\n      matchingRules.push(rule);\n    } else if (rule.oneOf) {\n      const matchingOneOfRules = rule.oneOf.filter(oneOfRule => isMatchingRule(oneOfRule, projectDir));\n      matchingRules.push(...matchingOneOfRules);\n      // } else if (isMatchingRule(rule, projectDir)) {\n    }\n  });\n\n  return matchingRules;\n}\n\n/**\n * Modify the webpack `entry` property so that the code in `sentry.server.config.js` and `sentry.client.config.js` is\n * included in the the necessary bundles.\n *\n * @param currentEntryProperty The value of the property before Sentry code has been injected\n * @param buildContext Object passed by nextjs containing metadata about the build\n * @returns The value which the new `entry` property (which will be a function) will return (TODO: this should return\n * the function, rather than the function's return value)\n */\nasync function addSentryToEntryProperty(\n  currentEntryProperty: WebpackEntryProperty,\n  buildContext: BuildContext,\n): Promise<EntryPropertyObject> {\n  // The `entry` entry in a webpack config can be a string, array of strings, object, or function. By default, nextjs\n  // sets it to an async function which returns the promise of an object of string arrays. Because we don't know whether\n  // someone else has come along before us and changed that, we need to check a few things along the way. The one thing\n  // we know is that it won't have gotten *simpler* in form, so we only need to worry about the object and function\n  // options. See https://webpack.js.org/configuration/entry-context/#entry.\n\n  const { isServer, dir: projectDir } = buildContext;\n\n  const newEntryProperty =\n    typeof currentEntryProperty === 'function' ? await currentEntryProperty() : { ...currentEntryProperty };\n\n  // `sentry.server.config.js` or `sentry.client.config.js` (or their TS equivalents)\n  const userConfigFile = isServer ? getUserConfigFile(projectDir, 'server') : getUserConfigFile(projectDir, 'client');\n\n  // we need to turn the filename into a path so webpack can find it\n  const filesToInject = [`./${userConfigFile}`];\n\n  // inject into all entry points which might contain user's code\n  for (const entryPointName in newEntryProperty) {\n    if (shouldAddSentryToEntryPoint(entryPointName, isServer)) {\n      addFilesToExistingEntryPoint(newEntryProperty, entryPointName, filesToInject);\n    }\n  }\n\n  return newEntryProperty;\n}\n\n/**\n * Search the project directory for a valid user config file for the given platform, allowing for it to be either a\n * TypeScript or JavaScript file.\n *\n * @param projectDir The root directory of the project, where the file should be located\n * @param platform Either \"server\" or \"client\", so that we know which file to look for\n * @returns The name of the relevant file. If no file is found, this method throws an error.\n */\nexport function getUserConfigFile(projectDir: string, platform: 'server' | 'client'): string {\n  const possibilities = [`sentry.${platform}.config.ts`, `sentry.${platform}.config.js`];\n\n  for (const filename of possibilities) {\n    if (fs.existsSync(path.resolve(projectDir, filename))) {\n      return filename;\n    }\n  }\n\n  throw new Error(`Cannot find '${possibilities[0]}' or '${possibilities[1]}' in '${projectDir}'.`);\n}\n\n/**\n * Add files to a specific element of the given `entry` webpack config property.\n *\n * @param entryProperty The existing `entry` config object\n * @param entryPointName The key where the file should be injected\n * @param filepaths An array of paths to the injected files\n */\nfunction addFilesToExistingEntryPoint(\n  entryProperty: EntryPropertyObject,\n  entryPointName: string,\n  filepaths: string[],\n): void {\n  // can be a string, array of strings, or object whose `import` property is one of those two\n  const currentEntryPoint = entryProperty[entryPointName];\n  let newEntryPoint = currentEntryPoint;\n\n  if (typeof currentEntryPoint === 'string') {\n    newEntryPoint = [...filepaths, currentEntryPoint];\n  } else if (Array.isArray(currentEntryPoint)) {\n    newEntryPoint = [...filepaths, ...currentEntryPoint];\n  }\n  // descriptor object (webpack 5+)\n  else if (typeof currentEntryPoint === 'object' && 'import' in currentEntryPoint) {\n    const currentImportValue = currentEntryPoint.import;\n    let newImportValue;\n\n    if (typeof currentImportValue === 'string') {\n      newImportValue = [...filepaths, currentImportValue];\n    } else {\n      newImportValue = [...filepaths, ...currentImportValue];\n    }\n\n    newEntryPoint = {\n      ...currentEntryPoint,\n      import: newImportValue,\n    };\n  }\n  // malformed entry point (use `console.error` rather than `logger.error` because it will always be printed, regardless\n  // of SDK settings)\n  else {\n    // eslint-disable-next-line no-console\n    console.error(\n      'Sentry Logger [Error]:',\n      `Could not inject SDK initialization code into entry point ${entryPointName}, as its current value is not in a recognized format.\\n`,\n      'Expected: string | Array<string> | { [key:string]: any, import: string | Array<string> }\\n',\n      `Got: ${currentEntryPoint}`,\n    );\n  }\n\n  entryProperty[entryPointName] = newEntryPoint;\n}\n\n/**\n * Check the SentryWebpackPlugin options provided by the user against the options we set by default, and warn if any of\n * our default options are getting overridden. (Note: If any of our default values is undefined, it won't be included in\n * the warning.)\n *\n * @param defaultOptions Default SentryWebpackPlugin options\n * @param userOptions The user's SentryWebpackPlugin options\n */\nfunction checkWebpackPluginOverrides(\n  defaultOptions: SentryWebpackPluginOptions,\n  userOptions: Partial<SentryWebpackPluginOptions>,\n): void {\n  // warn if any of the default options for the webpack plugin are getting overridden\n  const sentryWebpackPluginOptionOverrides = Object.keys(defaultOptions).filter(key => key in userOptions);\n  if (sentryWebpackPluginOptionOverrides.length > 0) {\n    __DEBUG_BUILD__ &&\n      logger.warn(\n        '[Sentry] You are overriding the following automatically-set SentryWebpackPlugin config options:\\n' +\n          `\\t${sentryWebpackPluginOptionOverrides.toString()},\\n` +\n          \"which has the possibility of breaking source map upload and application. This is only a good idea if you know what you're doing.\",\n      );\n  }\n}\n\n/**\n * Determine if this is an entry point into which both `Sentry.init()` code and the release value should be injected\n *\n * @param entryPointName The name of the entry point in question\n * @param isServer Whether or not this function is being called in the context of a server build\n * @returns `true` if sentry code should be injected, and `false` otherwise\n */\nfunction shouldAddSentryToEntryPoint(entryPointName: string, isServer: boolean): boolean {\n  return (\n    entryPointName === 'pages/_app' ||\n    (entryPointName.includes('pages/api') && !entryPointName.includes('_middleware')) ||\n    (isServer && entryPointName === 'pages/_error')\n  );\n}\n\n/**\n * Combine default and user-provided SentryWebpackPlugin options, accounting for whether we're building server files or\n * client files.\n *\n * @param buildContext Nexjs-provided data about the current build\n * @param userPluginOptions User-provided SentryWebpackPlugin options\n * @returns Final set of combined options\n */\nexport function getWebpackPluginOptions(\n  buildContext: BuildContext,\n  userPluginOptions: Partial<SentryWebpackPluginOptions>,\n  userSentryOptions: UserSentryOptions,\n): SentryWebpackPluginOptions {\n  const { buildId, isServer, webpack, config: userNextConfig, dev: isDev, dir: projectDir } = buildContext;\n  const distDir = userNextConfig.distDir ?? '.next'; // `.next` is the default directory\n\n  const isWebpack5 = webpack.version.startsWith('5');\n  const isServerless = userNextConfig.target === 'experimental-serverless-trace';\n  const hasSentryProperties = fs.existsSync(path.resolve(projectDir, 'sentry.properties'));\n  const urlPrefix = userNextConfig.basePath ? `~${userNextConfig.basePath}/_next` : '~/_next';\n\n  const serverInclude = isServerless\n    ? [{ paths: [`${distDir}/serverless/`], urlPrefix: `${urlPrefix}/serverless` }]\n    : [{ paths: [`${distDir}/server/pages/`], urlPrefix: `${urlPrefix}/server/pages` }].concat(\n        isWebpack5 ? [{ paths: [`${distDir}/server/chunks/`], urlPrefix: `${urlPrefix}/server/chunks` }] : [],\n      );\n\n  const clientInclude = userSentryOptions.widenClientFileUpload\n    ? [{ paths: [`${distDir}/static/chunks`], urlPrefix: `${urlPrefix}/static/chunks` }]\n    : [{ paths: [`${distDir}/static/chunks/pages`], urlPrefix: `${urlPrefix}/static/chunks/pages` }];\n\n  const defaultPluginOptions = dropUndefinedKeys({\n    include: isServer ? serverInclude : clientInclude,\n    ignore:\n      isServer || !userSentryOptions.widenClientFileUpload\n        ? []\n        : // Widening the upload scope is necessarily going to lead to us uploading files we don't need to (ones which\n          // don't include any user code). In order to lessen that where we can, exclude the internal nextjs files we know\n          // will be there.\n          ['framework-*', 'framework.*', 'main-*', 'polyfills-*', 'webpack-*'],\n    url: process.env.SENTRY_URL,\n    org: process.env.SENTRY_ORG,\n    project: process.env.SENTRY_PROJECT,\n    authToken: process.env.SENTRY_AUTH_TOKEN,\n    configFile: hasSentryProperties ? 'sentry.properties' : undefined,\n    stripPrefix: ['webpack://_N_E/'],\n    urlPrefix,\n    entries: (entryPointName: string) => shouldAddSentryToEntryPoint(entryPointName, isServer),\n    release: getSentryRelease(buildId),\n    dryRun: isDev,\n  });\n\n  checkWebpackPluginOverrides(defaultPluginOptions, userPluginOptions);\n\n  return { ...defaultPluginOptions, ...userPluginOptions };\n}\n\n/**\n * NOTE: We're faking `require.resolve` here as a workaround for @vercel/nft detecting the binary itself as a hard\n *       dependency and always including it in the bundle, which is not what we want.\n *\n * ref: https://github.com/getsentry/sentry-javascript/issues/3865\n * ref: https://github.com/vercel/nft/issues/203\n */\nfunction ensureCLIBinaryExists(): boolean {\n  for (const node_modulesPath of module.paths) {\n    if (fs.existsSync(path.resolve(node_modulesPath, '@sentry/cli/sentry-cli'))) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/** Check various conditions to decide if we should run the plugin */\nfunction shouldEnableWebpackPlugin(buildContext: BuildContext, userSentryOptions: UserSentryOptions): boolean {\n  const { isServer, dev: isDev } = buildContext;\n  const { disableServerWebpackPlugin, disableClientWebpackPlugin } = userSentryOptions;\n\n  /** Non-negotiable */\n\n  // TODO: this is a hack to fix https://github.com/getsentry/sentry-cli/issues/1085, which is caused by\n  // https://github.com/getsentry/sentry-cli/issues/915. Once the latter is addressed, this existence check can come\n  // out. (The check is necessary because currently, `@sentry/cli` uses a post-install script to download an\n  // architecture-specific version of the `sentry-cli` binary. If `yarn install`, `npm install`, or `npm ci` are run\n  // with the `--ignore-scripts` option, this will be blocked and the missing binary will cause an error when users\n  // try to build their apps.)\n  if (!ensureCLIBinaryExists()) {\n    return false;\n  }\n\n  /** User override */\n\n  if (isServer && disableServerWebpackPlugin !== undefined) {\n    return !disableServerWebpackPlugin;\n  } else if (!isServer && disableClientWebpackPlugin !== undefined) {\n    return !disableClientWebpackPlugin;\n  }\n\n  /** Situations where the default is to disable the plugin */\n\n  // TODO: Are there analogs to Vercel's preveiw and dev modes on other deployment platforms?\n\n  if (isDev || process.env.NODE_ENV === 'development') {\n    // TODO (v8): Right now in dev we set the plugin to dryrun mode, and our boilerplate includes setting the plugin to\n    // `silent`, so for the vast majority of users, it's as if the plugin doesn't run at all in dev. Making that\n    // official is technically a breaking change, though, so we probably should wait until v8.\n    // return false\n  }\n\n  if (process.env.VERCEL_ENV === 'preview' || process.env.VERCEL_ENV === 'development') {\n    return false;\n  }\n\n  // We've passed all of the tests!\n  return true;\n}\n\n/** Handle warning messages about `hideSourceMaps` option. Can be removed in v9 or v10 (or whenever we consider that\n * enough people will have upgraded the SDK that the warning about the default in v8 - currently commented out - is\n * overkill). */\nfunction handleSourcemapHidingOptionWarning(userSentryOptions: UserSentryOptions, isServer: boolean): void {\n  // This is nextjs's own logging formatting, vendored since it's not exported. See\n  // https://github.com/vercel/next.js/blob/c3ceeb03abb1b262032bd96457e224497d3bbcef/packages/next/build/output/log.ts#L3-L11\n  // and\n  // https://github.com/vercel/next.js/blob/de7aa2d6e486c40b8be95a1327639cbed75a8782/packages/next/lib/eslint/runLintCheck.ts#L321-L323.\n  const codeFormat = (str: string): string => chalk.bold.cyan(str);\n\n  const _warningPrefix_ = `${chalk.yellow('warn')}  -`;\n  const _sentryNextjs_ = codeFormat('@sentry/nextjs');\n  const _hideSourceMaps_ = codeFormat('hideSourceMaps');\n  const _true_ = codeFormat('true');\n  const _false_ = codeFormat('false');\n  const _sentry_ = codeFormat('sentry');\n  const _nextConfigJS_ = codeFormat('next.config.js');\n\n  if (isServer && userSentryOptions.hideSourceMaps === undefined) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\\n${_warningPrefix_} In order to be able to deminify errors, ${_sentryNextjs_} creates sourcemaps and uploads ` +\n        'them to the Sentry server. Depending on your deployment setup, this means your original code may be visible ' +\n        `in browser devtools in production. To prevent this, set ${_hideSourceMaps_} to ${_true_} in the ${_sentry_} ` +\n        `options in your ${_nextConfigJS_}. To disable this warning without changing sourcemap behavior, set ` +\n        `${_hideSourceMaps_} to ${_false_}. (In ${_sentryNextjs_} version 8.0.0 and beyond, this option will default ` +\n        `to ${_true_}.) See https://webpack.js.org/configuration/devtool/ and ` +\n        'https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/#use-hidden-source-map for more ' +\n        'information.\\n',\n    );\n  }\n\n  // TODO (v8): Remove the check above in favor of the one below\n\n  //   const infoPrefix = `${chalk.cyan('info')}  -`;\n  //\n  //   if (isServer && userSentryOptions.hideSourceMaps === true) {\n  //     // eslint-disable-next-line no-console\n  //     console.log(\n  //       `\\n${infoPrefix} Starting in ${_sentryNextjs_} version 8.0.0, ${_hideSourceMaps_} defaults to ${_true_}, and ` +\n  //         `thus can be removed from the ${_sentry_} options in ${_nextConfigJS_}. See ` +\n  //         'https://webpack.js.org/configuration/devtool/ and ' +\n  //         'https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/#use-hidden-source-map for more ' +\n  //         'information.\\n',\n  //     );\n  //   }\n}\n"],"names":[],"mappings":";;;;;;;;;AAsBA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6HA;;AAEA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;AAEA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;AAqBA;;AAEA;;;;;;;;;AASA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;AAEA;;;;;;;;;;;;;;;;;;AAkBA;;AAEA;;;;;;;AAOA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;;AAEA;;;;;;;;AAQA;;;AAGA;;;;;;;;;;;AAWA;;AAEA;;;;;;;AAOA;;;;;;AAMA;;AAEA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;AAEA;;;;;;;AAOA;;;;;;;AAOA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;"}