{"version":3,"file":"wrapperUtils.js","sources":["../../../../src/config/wrappers/wrapperUtils.ts"],"sourcesContent":["import { captureException, getCurrentHub, startTransaction } from '@sentry/core';\nimport { addRequestDataToEvent } from '@sentry/node';\nimport { getActiveTransaction } from '@sentry/tracing';\nimport { Transaction } from '@sentry/types';\nimport { extractTraceparentData, fill, isString, parseBaggageSetMutability } from '@sentry/utils';\nimport * as domain from 'domain';\nimport { IncomingMessage, ServerResponse } from 'http';\n\ndeclare module 'http' {\n  interface IncomingMessage {\n    _sentryTransaction?: Transaction;\n  }\n}\n\n/**\n * Grabs a transaction off a Next.js datafetcher request object, if it was previously put there via\n * `setTransactionOnRequest`.\n *\n * @param req The Next.js datafetcher request object\n * @returns the Transaction on the request object if there is one, or `undefined` if the request object didn't have one.\n */\nexport function getTransactionFromRequest(req: IncomingMessage): Transaction | undefined {\n  return req._sentryTransaction;\n}\n\nfunction setTransactionOnRequest(transaction: Transaction, req: IncomingMessage): void {\n  req._sentryTransaction = transaction;\n}\n\nfunction autoEndTransactionOnResponseEnd(transaction: Transaction, res: ServerResponse): void {\n  fill(res, 'end', (originalEnd: ServerResponse['end']) => {\n    return function (this: unknown, ...endArguments: Parameters<ServerResponse['end']>) {\n      transaction.finish();\n      return originalEnd.call(this, ...endArguments);\n    };\n  });\n}\n\n/**\n * Wraps a function that potentially throws. If it does, the error is passed to `captureException` and rethrown.\n *\n * Note: This function turns the wrapped function into an asynchronous one.\n */\nexport function withErrorInstrumentation<F extends (...args: any[]) => any>(\n  origFunction: F,\n): (...params: Parameters<F>) => Promise<ReturnType<F>> {\n  return async function (this: unknown, ...origFunctionArguments: Parameters<F>): Promise<ReturnType<F>> {\n    try {\n      return await origFunction.call(this, ...origFunctionArguments);\n    } catch (e) {\n      // TODO: Extract error logic from `withSentry` in here or create a new wrapper with said logic or something like that.\n      captureException(e);\n      throw e;\n    }\n  };\n}\n\n/**\n * Calls a server-side data fetching function (that takes a `req` and `res` object in its context) with tracing\n * instrumentation. A transaction will be created for the incoming request (if it doesn't already exist) in addition to\n * a span for the wrapped data fetching function.\n *\n * All of the above happens in an isolated domain, meaning all thrown errors will be associated with the correct span.\n *\n * @param origFunction The data fetching method to call.\n * @param origFunctionArguments The arguments to call the data fetching method with.\n * @param req The data fetching function's request object.\n * @param res The data fetching function's response object.\n * @param options Options providing details for the created transaction and span.\n * @returns what the data fetching method call returned.\n */\nexport function callTracedServerSideDataFetcher<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArguments: Parameters<F>,\n  req: IncomingMessage,\n  res: ServerResponse,\n  options: {\n    /** Parameterized route of the request - will be used for naming the transaction. */\n    requestedRouteName: string;\n    /** Name of the route the data fetcher was defined in - will be used for describing the data fetcher's span. */\n    dataFetcherRouteName: string;\n    /** Name of the data fetching method - will be used for describing the data fetcher's span. */\n    dataFetchingMethodName: string;\n  },\n): Promise<ReturnType<F>> {\n  return domain.create().bind(async () => {\n    let requestTransaction: Transaction | undefined = getTransactionFromRequest(req);\n\n    if (requestTransaction === undefined) {\n      const sentryTraceHeader = req.headers['sentry-trace'];\n      const rawBaggageString = req.headers && isString(req.headers.baggage) && req.headers.baggage;\n      const traceparentData =\n        typeof sentryTraceHeader === 'string' ? extractTraceparentData(sentryTraceHeader) : undefined;\n\n      const baggage = parseBaggageSetMutability(rawBaggageString, traceparentData);\n\n      const newTransaction = startTransaction({\n        op: 'nextjs.data.server',\n        name: options.requestedRouteName,\n        ...traceparentData,\n        metadata: {\n          source: 'route',\n          baggage,\n        },\n      });\n\n      requestTransaction = newTransaction;\n      autoEndTransactionOnResponseEnd(newTransaction, res);\n      setTransactionOnRequest(newTransaction, req);\n    }\n\n    const dataFetcherSpan = requestTransaction.startChild({\n      op: 'nextjs.data.server',\n      description: `${options.dataFetchingMethodName} (${options.dataFetcherRouteName})`,\n    });\n\n    const currentScope = getCurrentHub().getScope();\n    if (currentScope) {\n      currentScope.setSpan(dataFetcherSpan);\n      currentScope.addEventProcessor(event =>\n        addRequestDataToEvent(event, req, {\n          include: {\n            // When the `transaction` option is set to true, it tries to extract a transaction name from the request\n            // object. We don't want this since we already have a high-quality transaction name with a parameterized\n            // route. Setting `transaction` to `true` will clobber that transaction name.\n            transaction: false,\n          },\n        }),\n      );\n    }\n\n    try {\n      return await origFunction(...origFunctionArguments);\n    } finally {\n      dataFetcherSpan.finish();\n    }\n  })();\n}\n\n/**\n * Call a data fetcher and trace it. Only traces the function if there is an active transaction on the scope.\n *\n * We only do the following until we move transaction creation into this function: When called, the wrapped function\n * will also update the name of the active transaction with a parameterized route provided via the `options` argument.\n */\nexport async function callDataFetcherTraced<F extends (...args: any[]) => Promise<any> | any>(\n  origFunction: F,\n  origFunctionArgs: Parameters<F>,\n  options: {\n    parameterizedRoute: string;\n    dataFetchingMethodName: string;\n  },\n): Promise<ReturnType<F>> {\n  const { parameterizedRoute, dataFetchingMethodName } = options;\n\n  const transaction = getActiveTransaction();\n\n  if (!transaction) {\n    return origFunction(...origFunctionArgs);\n  }\n\n  // TODO: Make sure that the given route matches the name of the active transaction (to prevent background data\n  // fetching from switching the name to a completely other route) -- We'll probably switch to creating a transaction\n  // right here so making that check will probabably not even be necessary.\n  // Logic will be: If there is no active transaction, start one with correct name and source. If there is an active\n  // transaction, create a child span with correct name and source.\n  transaction.name = parameterizedRoute;\n  transaction.metadata.source = 'route';\n\n  // Capture the route, since pre-loading, revalidation, etc might mean that this span may happen during another\n  // route's transaction\n  const span = transaction.startChild({\n    op: 'nextjs.data.server',\n    description: `${dataFetchingMethodName} (${parameterizedRoute})`,\n  });\n\n  try {\n    return await origFunction(...origFunctionArgs);\n  } catch (err) {\n    if (span) {\n      span.finish();\n    }\n\n    // TODO Copy more robust error handling over from `withSentry`\n    captureException(err);\n    throw err;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}