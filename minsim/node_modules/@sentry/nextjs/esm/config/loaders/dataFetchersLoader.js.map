{"version":3,"file":"dataFetchersLoader.js","sources":["../../../../src/config/loaders/dataFetchersLoader.ts"],"sourcesContent":["/**\n * This loader auto-wraps a user's page-level data-fetching functions (`getStaticProps` and `getServerSideProps`) in\n * order to instrument them for tracing. At a high level, this is done by finding the relevant functions, renaming them\n * so as not to create a name collision, and then creating a new version of each function which is a wrapped version of\n * the original. We do this by parsing the user's code and some template code into ASTs, manipulating them, and then\n * turning them back into strings and appending our template code to the user's (modified) page code. Greater detail and\n * explanations can be found in situ in the functions below and in the helper functions in `ast.ts`.\n *\n * For `getInitialProps` we create a virtual proxy-module that re-exports all the exports and default exports of the\n * original file and wraps `getInitialProps`. We do this since it allows us to very generically wrap `getInitialProps`\n * for all kinds ways users might define default exports (which are a lot of ways).\n */\nimport { logger } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { isESM } from '../../utils/isESM';\nimport type { AST } from './ast';\nimport {\n  findDeclarations,\n  findExports,\n  getExportIdentifierNames,\n  hasDefaultExport,\n  makeAST,\n  removeComments,\n  renameIdentifiers,\n} from './ast';\nimport type { LoaderThis } from './types';\n\n// Map to keep track of each function's placeholder in the template and what it should be replaced with. (The latter\n// will get added as we process the user code. Setting it to an empty string here means TS won't complain when we set it\n// to a non-empty string later.)\nconst DATA_FETCHING_FUNCTIONS = {\n  getServerSideProps: { placeholder: '__ORIG_GSSP__', alias: '' },\n  getStaticProps: { placeholder: '__ORIG_GSPROPS__', alias: '' },\n};\n\ntype LoaderOptions = {\n  projectDir: string;\n  pagesDir: string;\n};\n\n/**\n * Find any data-fetching functions the user's code contains and rename them to prevent clashes, then whittle the\n * template exporting wrapped versions instead down to only the functions found.\n *\n * @param userCode The source code of the current page file\n * @param templateCode The source code of the full template, including all functions\n * @param filepath The path to the current pagefile, within the project directory\n * @returns A tuple of modified user and template code\n */\nfunction wrapFunctions(userCode: string, templateCode: string, filepath: string): string[] {\n  let userAST: AST, templateAST: AST;\n\n  try {\n    userAST = makeAST(userCode);\n    templateAST = makeAST(templateCode);\n  } catch (err) {\n    logger.warn(`Couldn't add Sentry to ${filepath} because there was a parsing error: ${err}`);\n    // Replace the template code with an empty string, so in the end the user code is untouched\n    return [userCode, ''];\n  }\n\n  // Comments are useful to have in the template for anyone reading it, but don't make sense to be injected into user\n  // code, because they're about the template-i-ness of the template, not the code itself\n  // TODO: Move this to our rollup build\n  removeComments(templateAST);\n\n  for (const functionName of Object.keys(DATA_FETCHING_FUNCTIONS)) {\n    // Find and rename all identifiers whose name is `functionName`\n    const alias = renameIdentifiers(userAST, functionName);\n\n    // `alias` will be defined iff the user code contains the function in question and renaming has been done\n    if (alias) {\n      // We keep track of the alias for each function, so that later on we can fill it in for the placeholder in the\n      // template. (Not doing that now because it's much more easily done once the template code has gone back to being\n      // a string.)\n      DATA_FETCHING_FUNCTIONS[functionName as keyof typeof DATA_FETCHING_FUNCTIONS].alias = alias;\n    }\n\n    // Otherwise, if the current function doesn't exist anywhere in the user's code, delete the code in the template\n    // wrapping that function\n    //\n    // Note: We start with all of the possible wrapper lines in the template and delete the ones we don't need (rather\n    // than starting with none and adding in the ones we do need) because it allows them to live in our souce code as\n    // *code*. If we added them in, they'd have to be strings containing code, and we'd lose all of the benefits of\n    // syntax highlighting, linting, etc.\n    else {\n      // We have to look for declarations and exports separately because when we build the SDK, Rollup turns\n      //     export const XXX = ...\n      // into\n      //     const XXX = ...\n      //     export { XXX }\n      findExports(templateAST, functionName).remove();\n      findDeclarations(templateAST, functionName).remove();\n    }\n  }\n\n  return [userAST.toSource(), templateAST.toSource()];\n}\n\n/**\n * Wrap `getInitialProps`, `getStaticProps`, and `getServerSideProps` (if they exist) in the given page code\n */\nexport default function wrapDataFetchersLoader(this: LoaderThis<LoaderOptions>, userCode: string): string {\n  // For now this loader only works for ESM code\n  if (!isESM(userCode)) {\n    return userCode;\n  }\n\n  // We know one or the other will be defined, depending on the version of webpack being used\n  const { projectDir, pagesDir } = 'getOptions' in this ? this.getOptions() : this.query;\n\n  // Get the parameterized route name from this page's filepath\n  const parameterizedRouteName = path\n    // Get the path of the file insde of the pages directory\n    .relative(pagesDir, this.resourcePath)\n    // Add a slash at the beginning\n    .replace(/(.*)/, '/$1')\n    // Pull off the file extension\n    .replace(/\\.(jsx?|tsx?)/, '')\n    // Any page file named `index` corresponds to root of the directory its in, URL-wise, so turn `/xyz/index` into\n    // just `/xyz`\n    .replace(/\\/index$/, '')\n    // In case all of the above have left us with an empty string (which will happen if we're dealing with the\n    // homepage), sub back in the root route\n    .replace(/^$/, '/');\n\n  // In the following branch we will proxy the user's file. This means we return code (basically an entirely new file)\n  // that re - exports all the user file's originial export, but with a \"sentry-proxy-loader\" query in the module\n  // string.\n  // This looks like the following: `export { a, b, c } from \"[imagine userfile path here]?sentry-proxy-loader\";`\n  // Additionally, in this proxy file we import the userfile's default export, wrap `getInitialProps` on that default\n  // export, and re -export the now modified default export as default.\n  // Webpack will resolve the module with the \"sentry-proxy-loader\" query to the original file, but will give us access\n  // to the query via`this.resourceQuery`. If we see that `this.resourceQuery` includes includes \"sentry-proxy-loader\"\n  // we know we're in a proxied file and do not need to proxy again.\n\n  if (!this.resourceQuery.includes('sentry-proxy-loader')) {\n    const ast = makeAST(userCode);\n    const exportedIdentifiers = getExportIdentifierNames(ast);\n\n    let outputFileContent = '';\n\n    if (exportedIdentifiers.length > 0) {\n      outputFileContent += `export { ${exportedIdentifiers.join(', ')} } from \"${\n        this.resourcePath\n      }?sentry-proxy-loader\";`;\n    }\n\n    if (hasDefaultExport(ast)) {\n      outputFileContent += `\n        import { default as _sentry_default } from \"${this.resourcePath}?sentry-proxy-loader\";\n        import {\n          withSentryServerSideGetInitialProps,\n          withSentryServerSideAppGetInitialProps,\n          withSentryServerSideDocumentGetInitialProps,\n          withSentryServerSideErrorGetInitialProps,\n        } from \"@sentry/nextjs\";`;\n\n      if (parameterizedRouteName === '/_app') {\n        outputFileContent += `\n          if (typeof _sentry_default.getInitialProps === 'function') {\n            _sentry_default.getInitialProps = withSentryServerSideAppGetInitialProps(_sentry_default.getInitialProps);\n          }`;\n      } else if (parameterizedRouteName === '/_document') {\n        outputFileContent += `\n          if (typeof _sentry_default.getInitialProps === 'function') {\n            _sentry_default.getInitialProps = withSentryServerSideDocumentGetInitialProps(_sentry_default.getInitialProps);\n          }`;\n      } else if (parameterizedRouteName === '/_error') {\n        outputFileContent += `\n          if (typeof _sentry_default.getInitialProps === 'function') {\n            _sentry_default.getInitialProps = withSentryServerSideErrorGetInitialProps(_sentry_default.getInitialProps);\n          }`;\n      } else {\n        // We enter this branch for any \"normal\" Next.js page\n        outputFileContent += `\n          if (typeof _sentry_default.getInitialProps === 'function') {\n            _sentry_default.getInitialProps = withSentryServerSideGetInitialProps(_sentry_default.getInitialProps);\n          }`;\n      }\n\n      outputFileContent += 'export default _sentry_default;';\n    }\n\n    return outputFileContent;\n  } else {\n    // If none of the functions we want to wrap appears in the page's code, there's nothing to do. (Note: We do this as a\n    // simple substring match (rather than waiting until we've parsed the code) because it's meant to be an\n    // as-fast-as-possible fail-fast. It's possible for user code to pass this check, even if it contains none of the\n    // functions in question, just by virtue of the correct string having been found, be it in a comment, as part of a\n    // longer variable name, etc. That said, when we actually do the code manipulation we'll be working on the code's AST,\n    // meaning we'll be able to differentiate between code we actually want to change and any false positives which might\n    // come up here.)\n    if (Object.keys(DATA_FETCHING_FUNCTIONS).every(functionName => !userCode.includes(functionName))) {\n      return userCode;\n    }\n\n    const templatePath = path.resolve(__dirname, '../templates/dataFetchersLoaderTemplate.js');\n    // make sure the template is included when runing `webpack watch`\n    this.addDependency(templatePath);\n\n    const templateCode = fs.readFileSync(templatePath).toString();\n\n    const [modifiedUserCode, modifiedTemplateCode] = wrapFunctions(\n      userCode,\n      templateCode,\n      // Relative path to the page we're currently processing, for use in error messages\n      path.relative(projectDir, this.resourcePath),\n    );\n\n    // Fill in template placeholders\n    let injectedCode = modifiedTemplateCode;\n\n    injectedCode = injectedCode.replace('__FILEPATH__', parameterizedRouteName);\n    for (const { placeholder, alias } of Object.values(DATA_FETCHING_FUNCTIONS)) {\n      injectedCode = injectedCode.replace(new RegExp(placeholder, 'g'), alias);\n    }\n\n    return `${modifiedUserCode}\\n${injectedCode}`;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}