{"version":3,"file":"withSentry.js","sources":["../../../src/utils/withSentry.ts"],"sourcesContent":["import { addRequestDataToEvent, captureException, flush, getCurrentHub, startTransaction } from '@sentry/node';\nimport { extractTraceparentData, hasTracingEnabled } from '@sentry/tracing';\nimport { Transaction } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  isString,\n  logger,\n  objectify,\n  parseBaggageSetMutability,\n  stripUrlQueryAndFragment,\n} from '@sentry/utils';\nimport * as domain from 'domain';\nimport { NextApiHandler, NextApiRequest, NextApiResponse } from 'next';\n\n// This is the same as the `NextApiHandler` type, except instead of having a return type of `void | Promise<void>`, it's\n// only `Promise<void>`, because wrapped handlers are always async\nexport type WrappedNextApiHandler = (req: NextApiRequest, res: NextApiResponse) => Promise<void>;\n\nexport type AugmentedNextApiResponse = NextApiResponse & {\n  __sentryTransaction?: Transaction;\n};\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const withSentry = (origHandler: NextApiHandler): WrappedNextApiHandler => {\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  return async (req, res) => {\n    // first order of business: monkeypatch `res.end()` so that it will wait for us to send events to sentry before it\n    // fires (if we don't do this, the lambda will close too early and events will be either delayed or lost)\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    res.end = wrapEndMethod(res.end);\n\n    // use a domain in order to prevent scope bleed between requests\n    const local = domain.create();\n    local.add(req);\n    local.add(res);\n\n    // `local.bind` causes everything to run inside a domain, just like `local.run` does, but it also lets the callback\n    // return a value. In our case, all any of the codepaths return is a promise of `void`, but nextjs still counts on\n    // getting that before it will finish the response.\n    const boundHandler = local.bind(async () => {\n      const currentScope = getCurrentHub().getScope();\n\n      if (currentScope) {\n        currentScope.addEventProcessor(event => addRequestDataToEvent(event, req));\n\n        if (hasTracingEnabled()) {\n          // If there is a trace header set, extract the data from it (parentSpanId, traceId, and sampling decision)\n          let traceparentData;\n          if (req.headers && isString(req.headers['sentry-trace'])) {\n            traceparentData = extractTraceparentData(req.headers['sentry-trace']);\n            __DEBUG_BUILD__ && logger.log(`[Tracing] Continuing trace ${traceparentData?.traceId}.`);\n          }\n\n          const rawBaggageString = req.headers && isString(req.headers.baggage) && req.headers.baggage;\n          const baggage = parseBaggageSetMutability(rawBaggageString, traceparentData);\n\n          const url = `${req.url}`;\n          // pull off query string, if any\n          let reqPath = stripUrlQueryAndFragment(url);\n          // Replace with placeholder\n          if (req.query) {\n            // TODO get this from next if possible, to avoid accidentally replacing non-dynamic parts of the path if\n            // they happen to match the values of any of the dynamic parts\n            for (const [key, value] of Object.entries(req.query)) {\n              reqPath = reqPath.replace(`${value}`, `[${key}]`);\n            }\n          }\n          const reqMethod = `${(req.method || 'GET').toUpperCase()} `;\n\n          const transaction = startTransaction(\n            {\n              name: `${reqMethod}${reqPath}`,\n              op: 'http.server',\n              ...traceparentData,\n              metadata: { baggage, source: 'route' },\n            },\n            // extra context passed to the `tracesSampler`\n            { request: req },\n          );\n          currentScope.setSpan(transaction);\n\n          // save a link to the transaction on the response, so that even if there's an error (landing us outside of\n          // the domain), we can still finish it (albeit possibly missing some scope data)\n          (res as AugmentedNextApiResponse).__sentryTransaction = transaction;\n        }\n      }\n\n      try {\n        const handlerResult = await origHandler(req, res);\n\n        if (process.env.NODE_ENV === 'development' && !process.env.SENTRY_IGNORE_API_RESOLUTION_ERROR) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `[sentry] If Next.js logs a warning \"API resolved without sending a response\", it's a false positive, which we're working to rectify.\n            In the meantime, to suppress this warning, set \\`SENTRY_IGNORE_API_RESOLUTION_ERROR\\` to 1 in your env.\n            To suppress the nextjs warning, use the \\`externalResolver\\` API route option (see https://nextjs.org/docs/api-routes/api-middlewares#custom-config for details).`,\n          );\n        }\n\n        return handlerResult;\n      } catch (e) {\n        // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n        // store a seen flag on it. (Because of the one-way-on-Vercel-one-way-off-of-Vercel approach we've been forced\n        // to take, it can happen that the same thrown object gets caught in two different ways, and flagging it is a\n        // way to prevent it from actually being reported twice.)\n        const objectifiedErr = objectify(e);\n\n        if (currentScope) {\n          currentScope.addEventProcessor(event => {\n            addExceptionMechanism(event, {\n              type: 'instrument',\n              handled: true,\n              data: {\n                wrapped_handler: origHandler.name,\n                function: 'withSentry',\n              },\n            });\n            return event;\n          });\n\n          captureException(objectifiedErr);\n        }\n\n        // Because we're going to finish and send the transaction before passing the error onto nextjs, it won't yet\n        // have had a chance to set the status to 500, so unless we do it ourselves now, we'll incorrectly report that\n        // the transaction was error-free\n        res.statusCode = 500;\n        res.statusMessage = 'Internal Server Error';\n\n        // Make sure we have a chance to finish the transaction and flush events to Sentry before the handler errors\n        // out. (Apps which are deployed on Vercel run their API routes in lambdas, and those lambdas will shut down the\n        // moment they detect an error, so it's important to get this done before rethrowing the error. Apps not\n        // deployed serverlessly will run into this cleanup function again in `res.end(), but it'll just no-op.)\n        await finishSentryProcessing(res);\n\n        // We rethrow here so that nextjs can do with the error whatever it would normally do. (Sometimes \"whatever it\n        // would normally do\" is to allow the error to bubble up to the global handlers - another reason we need to mark\n        // the error as already having been captured.)\n        throw objectifiedErr;\n      }\n    });\n\n    // Since API route handlers are all async, nextjs always awaits the return value (meaning it's fine for us to return\n    // a promise here rather than a real result, and it saves us the overhead of an `await` call.)\n    return boundHandler();\n  };\n};\n\ntype ResponseEndMethod = AugmentedNextApiResponse['end'];\ntype WrappedResponseEndMethod = AugmentedNextApiResponse['end'];\n\n/**\n * Wrap `res.end()` so that it closes the transaction and flushes events before letting the request finish.\n *\n * Note: This wraps a sync method with an async method. While in general that's not a great idea in terms of keeping\n * things in the right order, in this case it's safe, because the native `.end()` actually *is* async, and its run\n * actually *is* awaited, just manually so (which reflects the fact that the core of the request/response code in Node\n * by far predates the introduction of `async`/`await`). When `.end()` is done, it emits the `prefinish` event, and\n * only once that fires does request processing continue. See\n * https://github.com/nodejs/node/commit/7c9b607048f13741173d397795bac37707405ba7.\n *\n * @param origEnd The original `res.end()` method\n * @returns The wrapped version\n */\nfunction wrapEndMethod(origEnd: ResponseEndMethod): WrappedResponseEndMethod {\n  return async function newEnd(this: AugmentedNextApiResponse, ...args: unknown[]) {\n    await finishSentryProcessing(this);\n\n    return origEnd.call(this, ...args);\n  };\n}\n\n/**\n * Close the open transaction (if any) and flush events to Sentry.\n *\n * @param res The outgoing response for this request, on which the transaction is stored\n */\nasync function finishSentryProcessing(res: AugmentedNextApiResponse): Promise<void> {\n  const { __sentryTransaction: transaction } = res;\n\n  if (transaction) {\n    transaction.setHttpStatus(res.statusCode);\n\n    // Push `transaction.finish` to the next event loop so open spans have a better chance of finishing before the\n    // transaction closes, and make sure to wait until that's done before flushing events\n    const transactionFinished: Promise<void> = new Promise(resolve => {\n      setImmediate(() => {\n        transaction.finish();\n        resolve();\n      });\n    });\n    await transactionFinished;\n  }\n\n  // Flush the event queue to ensure that events get sent to Sentry before the response is finished and the lambda\n  // ends. If there was an error, rethrow it so that the normal exception-handling mechanisms can apply.\n  try {\n    __DEBUG_BUILD__ && logger.log('Flushing events...');\n    await flush(2000);\n    __DEBUG_BUILD__ && logger.log('Done flushing events');\n  } catch (e) {\n    __DEBUG_BUILD__ && logger.log('Error while flushing events:\\n', e);\n  }\n}\n"],"names":[],"mappings":";;;;;;AAcA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmIA;;AAKA;;;;;;;;;;;;;AAaA;;;;;;AAMA;;AAEA;;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;"}