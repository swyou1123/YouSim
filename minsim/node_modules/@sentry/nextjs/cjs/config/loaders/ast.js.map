{"version":3,"file":"ast.js","sources":["../../../../src/config/loaders/ast.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport * as jscsTypes from 'jscodeshift';\nimport { default as jscodeshiftDefault } from 'jscodeshift';\n\nimport { parser } from './parser';\n\n// In `jscodeshift`, the exports look like this:\n//\n//     function core(...) { ... }\n//     core.ABC = ...\n//     core.XYZ = ...\n//     module.exports = core\n//\n// In other words, when required/imported, the module is both a callable function and an object containing all sorts of\n// properties. Meanwhile, its TS export is a namespace continaing the types of all of the properties attached to `core`.\n// In order to use the types, we thus need to use `import *` syntax. But when we do that, Rollup only sees it as a\n// namespace, and will complain if we try to use it as a function. In order to get around this, we take advantage of the\n// fact that Rollup wraps imports in its own version of TS's `esModuleInterop` functions, aliasing the export to a\n// `default` property inside the export. (So, here, we basically end up with `core.default = core`.) When referenced\n// through that alias, `core` is correctly seen as callable by Rollup. Outside of a Rollup context, however, that\n// `default` alias doesn't exist. So, we try both and use whichever one is defined. (See\n// https://github.com/rollup/rollup/issues/1267.)\nconst jscodeshiftNamespace = jscsTypes;\nconst jscs = jscodeshiftDefault || jscodeshiftNamespace;\n\n// These are types not in the TS sense, but in the instance-of-a-Type-class sense\nconst {\n  ArrayPattern,\n  ClassDeclaration,\n  ExportAllDeclaration,\n  ExportDefaultDeclaration,\n  ExportDefaultSpecifier,\n  ExportNamedDeclaration,\n  ExportSpecifier,\n  FunctionDeclaration,\n  Identifier,\n  ImportSpecifier,\n  JSXIdentifier,\n  MemberExpression,\n  Node,\n  ObjectExpression,\n  ObjectPattern,\n  Property,\n  RestElement,\n  TSTypeParameter,\n  VariableDeclaration,\n  VariableDeclarator,\n} = jscs;\n\ntype ASTNode = jscsTypes.ASTNode;\nexport type AST<T = ASTNode> = jscsTypes.Collection<T>;\n// `parentPath` is on the prototype, but not included in the type for some reason. (`parent`, which is an instance\n// property referencing the same object as `parentPath`, is in the type, and we could use that instead. But the\n// `parentPath` name makes it clearer that said object is in fact a `NodePath`, not a `Node`, so we choose to use it\n// over `parent`, even if it means adding it to the type.)\ninterface ASTPath<T = ASTNode> extends jscsTypes.ASTPath<T> {\n  parentPath: ASTPath<ASTNode>;\n}\ntype IdentifierNode = jscsTypes.Identifier;\ntype ExportSpecifierNode = jscsTypes.ExportSpecifier;\ntype VariableDeclarationNode = jscsTypes.VariableDeclaration;\n\n/**\n * Create an AST based on the given code.\n *\n * @param code The code to convert to an AST.\n * @throws Throws parsing error if the code is unparsable\n * @returns The AST\n */\nexport function makeAST(code: string): AST {\n  // If this errors, it will be caught in the calling function, where we know more information and can construct a\n  // better warning message\n  return jscs(code, { parser });\n}\n\n/**\n * Find all nodes which represent Identifiers with the given name\n *\n * @param ast The code, in AST form\n * @param name The Identifier name to search for\n * @returns A collection of NodePaths pointing to any nodes which were found\n */\nfunction findIdentifiers(ast: AST, name: string): AST<IdentifierNode> {\n  const identifierFilter = function (path: ASTPath<IdentifierNode>): boolean {\n    // Check that what we have is indeed an Identifier, and that the name matches\n    //\n    // Note: If we were being super precise about this, we'd also check the context in which the identifier is being\n    // used, because there are some cases where we actually don't want to be renaming things (if the identifier is being\n    // used to name a class property, for example). But the chances that someone is going to have a class property in a\n    // nextjs page file with the same name as one of the canonical functions are slim to none, so for simplicity we can\n    // stop filtering here. If this ever becomes a problem, more precise filter checks can be found in a comment at the\n    // bottom of this file.\n    return path.node.name === name;\n  };\n\n  return ast.find(Identifier).filter(identifierFilter);\n}\n\n/**\n * Find all nodes which are declarations of variables with the given name\n *\n * @param ast The code, in AST form\n * @param name The variable name to search for\n * @returns A collection of NodePaths pointing to any nodes which were found\n */\nexport function findDeclarations(ast: AST, name: string): AST<VariableDeclarationNode> {\n  // Check for a structure of the form\n  //\n  //     node: VariableDeclaration\n  //      \\\n  //       declarations: VariableDeclarator[]\n  //        \\\n  //         0 : VariableDeclarator\n  //          \\\n  //           id: Identifier\n  //            \\\n  //             name: string\n  //\n  // where `name` matches the given name.\n  const declarationFilter = function (path: ASTPath<VariableDeclarationNode>): boolean {\n    return (\n      path.node.declarations.length === 1 &&\n      VariableDeclarator.check(path.node.declarations[0]) &&\n      Identifier.check(path.node.declarations[0].id) &&\n      path.node.declarations[0].id.name === name\n    );\n  };\n\n  return ast.find(VariableDeclaration).filter(declarationFilter);\n}\n\n/**\n * Find all nodes which are exports of variables with the given name\n *\n * @param ast The code, in AST form\n * @param name The variable name to search for\n * @returns A collection of NodePaths pointing to any nodes which were found\n */\nexport function findExports(ast: AST, name: string): AST<ExportSpecifierNode> {\n  const exportFilter = function (path: ASTPath<ExportSpecifierNode>): boolean {\n    return ExportSpecifier.check(path.node) && path.node.exported.name === name;\n  };\n\n  return ast.find(ExportSpecifier).filter(exportFilter);\n}\n\n/**\n * Rename all identifiers with the given name, except in cases where it would break outside references.\n *\n * @param ast The AST representing the code\n * @param origName The name being replaced\n * @param newName The new name to use, if already chosen (one will be generated if not given)\n * @returns The new name assigned to the identifiers, or undefined if no identifiers were renamed\n */\nexport function renameIdentifiers(ast: AST, origName: string, newName?: string): string | undefined {\n  const matchingNodes = findIdentifiers(ast, origName);\n\n  if (matchingNodes.length > 0) {\n    // Find an available new name for the function by prefixing all references to it with an underscore (or a few\n    // underscores, if that's what it takes to avoid a name collision).\n    const alias = newName || findAvailibleAlias(ast, origName);\n    matchingNodes.forEach(nodePath => {\n      // Rename the node, except in cases where it might break an outside reference to it.\n      maybeRenameNode(ast, nodePath, alias);\n    });\n    return alias;\n  }\n\n  // technically redundant, but needed to keep TS happy\n  return undefined;\n}\n\n/**\n * Find an unused identifier name in the AST by repeatedly adding underscores to the beginning of the given original\n * name until we find one which hasn't already been taken.\n *\n * @param userAST The AST to search\n * @param origName The original name we want to alias\n * @returns\n */\nfunction findAvailibleAlias(userAST: AST, origName: string): string {\n  let foundAvailableName = false;\n  let newName = origName;\n\n  while (!foundAvailableName) {\n    // Prefix the original function name (or the last name we tried) with an underscore and search for identifiers with\n    // the new name in the AST\n    newName = `_${newName}`;\n    const existingIdentifiers = findIdentifiers(userAST, newName);\n\n    // If we haven't found anything, we're good to go\n    foundAvailableName = existingIdentifiers.length === 0;\n  }\n\n  return newName;\n}\n\n// When we're searching for and renaming the user's data-fetching functions, the general idea is to rename all\n// identifiers matching the function names, but there are a few things to watch out for:\n//   - We can't rename any identifiers that refer to something outside of the module, because then we'd break the link\n//     between the external thing and the module's reference to it. The two key examples of this are named imports and\n//     property access in objects instantiated outside of the module.\n//   - What nextjs cares about is just the identifier which gets exported, which may or may not be what it's called\n//     locally. In other words, if we find something like `export { something as getServerSideProps }`, we have to\n//     rename both `something` and `getServerSideProps`, the former so we can wrap it and the latter so as not to\n//     conflict with the wrapped function of the same name we're planning to export.\n//   - Shorthand object notation is a thing. Specifically, it's a thing which makes two separate identifiers appear as\n//     one, even though they have separate functions and may need to be treated differently from one another. This shows\n//     up not just in object literals but also when destructuring and in imports and exports.\n\nfunction maybeRenameNode(ast: AST, identifierPath: ASTPath<IdentifierNode>, alias: string): void {\n  const node = identifierPath.node;\n  const parent = identifierPath.parentPath.node;\n  const grandparent = identifierPath.parentPath.parentPath.node;\n\n  // In general we want to rename all nodes, unless we're in one of a few specific situations. (Anything which doesn't\n  // get handled by one of these checks will be renamed at the end of this function.) In all of the scenarios below,\n  // we'll use `gSSP` as our stand-in for either of `getServerSideProps` and `getStaticProps`.\n\n  // Imports:\n  //\n  //   - `import { gSSP } from 'yyy'`, which is equivalent (in AST terms) to `import { gSSP as gSSP } from 'yyy'`\n  //   - `import { xxx as gSSP } from 'yyy'`\n  //\n  // The `xxx as gSSP` corresponds to an ImportSpecifier, with `imported = xxx` and `local = gSSP`. In both of these\n  // cases, we want to rename `local` (the thing on the right; that will happen below) but not `imported` (the thing on\n  // the left).\n  if (ImportSpecifier.check(parent)) {\n    if (node === parent.imported) return;\n    // The only other option is that `node === parent.local`. This will get renamed below.\n  }\n\n  // Destructuring:\n  //\n  //   - `const { gSSP } = yyy`, which is equivalent (in AST terms) to `const { gSSP:gSSP } = yyy`\n  //   - `const { xxx:gSSP } = yyy`\n  //\n  // This would come up if, for example, we were grabbing something from a namespace (`import * as yyy from 'zzz'; const\n  // { xxx:gSSP } = yyy`). Here the `xxx:gSSP` corresponds to a Property (inside of an array inside of an ObjectPatten\n  // inside of a VariableDeclarator), with `key = xxx` and `value = gSSP`. In both of these cases, we want to rename\n  // `value` but not `key`. (Again here we're renaming the righthand thing but leaving the lefthand thing alone.)\n\n  // And\n  // though it's unlikely to be as relevant here, it's worth noting that we see the exact same pattern when\n  // instantiating an object literal - `{ xxx }` or `{ xxx: yyy }` - where we rename the value but not the key. The only\n  // difference there is that it's an `ObjectExpression` rather than an `ObjectPattern`.)\n  if (Property.check(parent) && ObjectPattern.check(grandparent)) {\n    if (node === parent.key) return;\n    // The only other option is that `node === parent.value`. This will get renamed below. When it does, the names of\n    // `parent.key` and `parent.value` won't match (if they ever did), so we need to make sure to update `shorthand`.\n    parent.shorthand = false;\n  }\n\n  // Object literal instantiation:\n  //\n  //   - `const xxx = { gSSP }`, which is equivalent (in AST terms) to `const xxx = { gSSP: gSSP }`\n  //   - `const xxx = { yyy: gSSP }`\n  //\n  // This is the same as destructuring in every way, with the exception that where there it was an `ObjectPattern`, here\n  // it's an `ObjectExpression`.\n  if (Property.check(parent) && ObjectExpression.check(grandparent)) {\n    if (node === parent.key) return;\n    // The only other option is that `node === parent.value`. This will get renamed below. When it does, the names of\n    // `parent.key` and `parent.value` won't match (if they ever did), so we need to make sure to update `shorthand`.\n    parent.shorthand = false;\n  }\n\n  // Object property access:\n  //\n  //   - xxx.yyy\n  //\n  // This is similar to destructuring (in that we we don't want to rename object keys), and would come up in similar\n  // circumstances: `import * as xxx from 'abc'; const zzz = xxx.yyy`. In this case the `xxx.yyy` corresponds to a\n  // `MemberExpression`, with `object = xxx` and `property = yyy`. (This is unlikely to be relevant in our case with\n  // data-fetching functions, which is why none of the part of this example are `gSSP`. Nonetheless, good to be accurate\n  // with these things.)\n  if (MemberExpression.check(parent)) {\n    if (node === parent.property) return;\n    // The only other option is that `node === parent.object`. This will get renamed below.\n  }\n\n  // Exports:\n  //\n  //   - `export { gSSP }, which is equivalent (in AST terms) to `export { gSSP as gSSP }`\n  //   - `export { xxx as gSSP }`\n  //\n  // Similar to the `import` cases, here the `xxx as gSSP` corresponds to an `ExportSpecifier`, with `local = xxx` and\n  // `exported = gSSP`. And as before, we want to change `local`, but this time there's a twist. (Two of them,\n  // actually.)\n  //\n  // First, if we care about this ExportSpecifier at all, it's because it's the export of one of our data-fetching\n  // functions, as in the example above. Because we want to export a replacement version of said function, we need to\n  // rename `exported`, to prevent a name conflict. (This is different than what you'd expect from a simple \"rename a\n  // variable\" algorithm, because in that case you normally wouldn't rename the thing which could be referred to outside\n  // of the module.)\n  //\n  // Second, because need to wrap the object using its local name, we need to rename `local`. This tracks with how we\n  // thought about `import` statements above, but is different from everything else we're doing in this function in that\n  // it means we potentially need to rename something *not* already named `getServerSideProps` or `getStaticProps`,\n  // meaning we need to rename nodes outside of the collection upon which we're currently acting.\n  if (ExportSpecifier.check(parent)) {\n    if (parent.exported.name !== parent.local?.name && node === parent.exported) {\n      const currentLocalName = parent.local?.name || '';\n      renameIdentifiers(ast, currentLocalName, alias);\n    }\n\n    // The only other options are that a) the names match, in which case both `local` and `exported` both have the name\n    // of the function we're trying to wrap, and will get renamed below, or b) the names are different but `node` is\n    // `local`, meaning this must be the second go-round of `renameIdentifiers`, where we're renaming everything with\n    // the local name, not the name of our wrapped data-fetching function, in which case `node` (a.k.a. `local`) will\n    // also get renamed below.\n  }\n\n  // handle any node which hasn't gotten otherwise dealt with above\n  node.name = alias;\n}\n\n/**\n * Remove comments from all nodes in the given AST.\n *\n * Note: Comments are not nodes in and of themselves, but are instead attached to the nodes above and below them.\n *\n * @param ast The code, in AST form\n */\nexport function removeComments(ast: AST): void {\n  const nodesWithComments = ast.find(Node).filter(nodePath => !!nodePath.node.comments);\n  nodesWithComments.forEach(nodePath => (nodePath.node.comments = null));\n}\n\n/**\n * Determines from a given AST of a file whether the file has a default export or not.\n */\nexport function hasDefaultExport(ast: AST): boolean {\n  const defaultExports = ast.find(Node, value => {\n    return (\n      ExportDefaultDeclaration.check(value) ||\n      ExportDefaultSpecifier.check(value) ||\n      (ExportSpecifier.check(value) && value.exported.name === 'default')\n    );\n  });\n\n  // In theory there should only ever be 0 or 1, but who knows what people do\n  return defaultExports.length > 0;\n}\n\n/**\n * Extracts all identifier names (`'constName'`) from an destructuringassignment'sArrayPattern (the `[constName]` in`const [constName] = [1]`).\n *\n * This function recursively calls itself and `getExportIdentifiersFromObjectPattern` since destructuring assignments\n * can be deeply nested with objects and arrays.\n *\n * Example - take the following program:\n *\n * ```js\n * export const [{ foo: name1 }, [{ bar: [name2]}, name3]] = [{ foo: 1 }, [{ bar: [2] }, 3]];\n * ```\n *\n * The `ArrayPattern` node in question for this program is the left hand side of the assignment:\n * `[{ foo: name1 }, [{ bar: [name2]}, name3]]`\n *\n * Applying this function to this `ArrayPattern` will return the following: `[\"name1\", \"name2\", \"name3\"]`\n *\n * DISCLAIMER: This function only correcly extracts identifiers of `ArrayPatterns` in the context of export statements.\n * Using this for `ArrayPattern` outside of exports would require us to handle more edgecases. Hence the \"Export\" in\n * this function's name.\n */\nfunction getExportIdentifiersFromArrayPattern(arrayPattern: jscsTypes.ArrayPattern): string[] {\n  const identifiers: string[] = [];\n\n  arrayPattern.elements.forEach(element => {\n    if (Identifier.check(element)) {\n      identifiers.push(element.name);\n    } else if (ObjectPattern.check(element)) {\n      identifiers.push(...getExportIdentifiersFromObjectPattern(element));\n    } else if (ArrayPattern.check(element)) {\n      identifiers.push(...getExportIdentifiersFromArrayPattern(element));\n    } else if (RestElement.check(element) && Identifier.check(element.argument)) {\n      // `RestElements` are spread operators\n      identifiers.push(element.argument.name);\n    }\n  });\n\n  return identifiers;\n}\n\n/**\n * Grabs all identifiers from an ObjectPattern within a destructured named export declaration\n * statement (`name` in \"export const { val: name } = { val: 1 }\").\n *\n * This function recursively calls itself and `getExportIdentifiersFromArrayPattern` since destructuring assignments\n * can be deeply nested with objects and arrays.\n *\n * Example - take the following program:\n *\n * ```js\n * export const { foo: [{ bar: name1 }], name2, ...name3 } = { foo: [{}] };\n * ```\n *\n * The `ObjectPattern` node in question for this program is the left hand side of the assignment:\n * `{ foo: [{ bar: name1 }], name2, ...name3 } = { foo: [{}] }`\n *\n * Applying this function to this `ObjectPattern` will return the following: `[\"name1\", \"name2\", \"name3\"]`\n *\n * DISCLAIMER: This function only correcly extracts identifiers of `ObjectPatterns` in the context of export statements.\n * Using this for `ObjectPatterns` outside of exports would require us to handle more edgecases. Hence the \"Export\" in\n * this function's name.\n */\nfunction getExportIdentifiersFromObjectPattern(objectPatternNode: jscsTypes.ObjectPattern): string[] {\n  const identifiers: string[] = [];\n\n  objectPatternNode.properties.forEach(property => {\n    // An `ObjectPattern`'s properties can be either `Property`s or `RestElement`s.\n    if (Property.check(property)) {\n      if (Identifier.check(property.value)) {\n        identifiers.push(property.value.name);\n      } else if (ObjectPattern.check(property.value)) {\n        identifiers.push(...getExportIdentifiersFromObjectPattern(property.value));\n      } else if (ArrayPattern.check(property.value)) {\n        identifiers.push(...getExportIdentifiersFromArrayPattern(property.value));\n      } else if (RestElement.check(property.value) && Identifier.check(property.value.argument)) {\n        // `RestElements` are spread operators\n        identifiers.push(property.value.argument.name);\n      }\n      // @ts-ignore AST types are wrong here\n    } else if (RestElement.check(property) && Identifier.check(property.argument)) {\n      // `RestElements` are spread operators\n      // @ts-ignore AST types are wrong here\n      identifiers.push(property.argument.name as string);\n    }\n  });\n\n  return identifiers;\n}\n\n/**\n * Given the AST of a file, this function extracts all named exports from the file.\n *\n * @returns a list of deduplicated identifiers.\n */\nexport function getExportIdentifierNames(ast: AST): string[] {\n  // We'll use a set to dedupe at the end, but for now we use an array as our accumulator because you can add multiple elements to it at once.\n  const identifiers: string[] = [];\n\n  // The following variable collects all export statements that double as named declaration, e.g.:\n  // - export function myFunc() {}\n  // - export var myVar = 1337\n  // - export const myConst = 1337\n  // - export const { a, ..rest } = { a: 1, b: 2, c: 3 }\n  // We will narrow those situations down in subsequent code blocks.\n  const namedExportDeclarationNodeDeclarations = ast\n    .find(ExportNamedDeclaration)\n    .nodes()\n    .map(namedExportDeclarationNode => namedExportDeclarationNode.declaration);\n\n  namedExportDeclarationNodeDeclarations\n    .filter((declarationNode): declarationNode is jscsTypes.VariableDeclaration =>\n      // Narrow down to varible declarations, e.g.:\n      // export const a = ...;\n      // export var b = ...;\n      // export let c = ...;\n      // export let c, d = 1;\n      VariableDeclaration.check(declarationNode),\n    )\n    .map(\n      variableDeclarationNode =>\n        // Grab all declarations in a single export statement.\n        // There can be multiple in the case of for example in `export let a, b;`.\n        variableDeclarationNode.declarations,\n    )\n    .reduce((prev, curr) => [...prev, ...curr], []) // flatten - now we have all declaration nodes in one flat array\n    .forEach(declarationNode => {\n      if (\n        Identifier.check(declarationNode) || // should never happen\n        JSXIdentifier.check(declarationNode) || // JSX like `<name></name>` - we don't care about these\n        TSTypeParameter.check(declarationNode) // type definitions - we don't care about those\n      ) {\n        // We should never have to enter this branch, it is just for type narrowing.\n      } else if (Identifier.check(declarationNode.id)) {\n        // If it's a simple declaration with an identifier we collect it. (e.g. `const myIdentifier = 1;` -> \"myIdentifier\")\n        identifiers.push(declarationNode.id.name);\n      } else if (ObjectPattern.check(declarationNode.id)) {\n        // If we encounter a destructuring export like `export const { foo: name1, bar: name2 } = { foo: 1, bar: 2 };`,\n        // we try collecting the identifiers from the pattern `{ foo: name1, bar: name2 }`.\n        identifiers.push(...getExportIdentifiersFromObjectPattern(declarationNode.id));\n      } else if (ArrayPattern.check(declarationNode.id)) {\n        // If we encounter a destructuring export like `export const [name1, name2] = [1, 2];`,\n        // we try collecting the identifiers from the pattern `[name1, name2]`.\n        identifiers.push(...getExportIdentifiersFromArrayPattern(declarationNode.id));\n      }\n    });\n\n  namedExportDeclarationNodeDeclarations\n    .filter(\n      // Narrow down to class and function declarations, e.g.:\n      // export class Foo {};\n      // export function bar() {};\n      (declarationNode): declarationNode is jscsTypes.ClassDeclaration | jscsTypes.FunctionDeclaration =>\n        ClassDeclaration.check(declarationNode) || FunctionDeclaration.check(declarationNode),\n    )\n    .map(node => node.id) // Grab the identifier of the function/class - Note: it might be `null` when it's anonymous\n    .filter((id): id is jscsTypes.Identifier => Identifier.check(id)) // Elaborate way of null-checking\n    .forEach(id => identifiers.push(id.name)); // Collect the name of the identifier\n\n  ast\n    .find(ExportSpecifier) // Find stuff like `export {<id [as name]>} [from ...];`\n    .nodes()\n    .forEach(specifier => {\n      // Taking the example above `specifier.exported.name` always contains `id` unless `name` is specified, then it's `name`;\n      if (specifier.exported.name !== 'default') {\n        // You can do default exports \"export { something as default };\" but we do not want to collect \"default\" in this\n        // function since it only wants to collect named exports.\n        identifiers.push(specifier.exported.name);\n      }\n    });\n\n  ast\n    .find(ExportAllDeclaration) // Find stuff like `export * from ...\" and \"export * as someVariable from ...`\n    .nodes()\n    .forEach(declaration => {\n      // Narrow it down to only find `export * as someVariable from ...` (emphasis on \"as someVariable\")\n      if (declaration.exported) {\n        identifiers.push(declaration.exported.name); // `declaration.exported.name` contains \"someVariable\"\n      }\n    });\n\n  return [...new Set(identifiers)]; // dedupe\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AAqBA;;AAeA;;;;;;;;;;;AAWA;;AAEA;;;;;;;AAOA;;;;;;;;;;;;;;AAcA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA;;AAEA;;;;;;;;;;;;;AAaA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;AAEA;;;;;;;;AAQA;;;;;;;;;;;;;;;AAeA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA;;AAEA;;;;;;;;;;AAUA;;AAEA;;;;;;;;;;;;;;AAcA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;;;;;;;;;;;;;;;;;AAiBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4FA;;;;;;;;"}