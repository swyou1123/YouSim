{"version":3,"file":"proxyLoader.js","sources":["../../../../src/config/loaders/proxyLoader.ts"],"sourcesContent":["import { escapeStringForRegex } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nimport { rollupize } from './rollup';\nimport { LoaderThis } from './types';\n\ntype LoaderOptions = {\n  pagesDir: string;\n};\n\n/**\n * Replace the loaded file with a proxy module \"wrapping\" the original file. In the proxy, the original file is loaded,\n * any data-fetching functions (`getInitialProps`, `getStaticProps`, and `getServerSideProps`) it contains are wrapped,\n * and then everything is re-exported.\n */\nexport default async function proxyLoader(this: LoaderThis<LoaderOptions>, userCode: string): Promise<string> {\n  // We know one or the other will be defined, depending on the version of webpack being used\n  const { pagesDir } = 'getOptions' in this ? this.getOptions() : this.query;\n\n  // Get the parameterized route name from this page's filepath\n  const parameterizedRoute = path\n    // Get the path of the file insde of the pages directory\n    .relative(pagesDir, this.resourcePath)\n    // Add a slash at the beginning\n    .replace(/(.*)/, '/$1')\n    // Pull off the file extension\n    .replace(/\\.(jsx?|tsx?)/, '')\n    // Any page file named `index` corresponds to root of the directory its in, URL-wise, so turn `/xyz/index` into\n    // just `/xyz`\n    .replace(/\\/index$/, '')\n    // In case all of the above have left us with an empty string (which will happen if we're dealing with the\n    // homepage), sub back in the root route\n    .replace(/^$/, '/');\n\n  // TODO: For the moment we skip API routes. Those will need to be handled slightly differently because of the manual\n  // wrapping we've already been having people do using `withSentry`.\n  if (parameterizedRoute.startsWith('api')) {\n    return userCode;\n  }\n\n  // We don't want to wrap twice (or infinitely), so in the proxy we add this query string onto references to the\n  // wrapped file, so that we know that it's already been processed. (Adding this query string is also necessary to\n  // convince webpack that it's a different file than the one it's in the middle of loading now, so that the originals\n  // themselves will have a chance to load.)\n  if (this.resourceQuery.includes('__sentry_wrapped__')) {\n    return userCode;\n  }\n\n  const templatePath = path.resolve(__dirname, '../templates/proxyLoaderTemplate.js');\n  let templateCode = fs.readFileSync(templatePath).toString();\n  // Make sure the template is included when runing `webpack watch`\n  this.addDependency(templatePath);\n\n  // Inject the route into the template\n  templateCode = templateCode.replace(/__ROUTE__/g, parameterizedRoute);\n\n  // Fill in the path to the file we're wrapping and save the result as a temporary file in the same folder (so that\n  // relative imports and exports are calculated correctly).\n  //\n  // TODO: We're saving the filled-in template to disk, however temporarily, because Rollup expects a path to a code\n  // file, not code itself. There is a rollup plugin which can fake this (`@rollup/plugin-virtual`) but the virtual file\n  // seems to be inside of a virtual directory (in other words, one level down from where you'd expect it) and that\n  // messes up relative imports and exports. Presumably there's a way to make it work, though, and if we can, it would\n  // be cleaner than having to first write and then delete a temporary file each time we run this loader.\n  templateCode = templateCode.replace(/__RESOURCE_PATH__/g, this.resourcePath);\n  const tempFilePath = path.resolve(path.dirname(this.resourcePath), `temp${Math.random()}.js`);\n  fs.writeFileSync(tempFilePath, templateCode);\n\n  // Run the proxy module code through Rollup, in order to split the `export * from '<wrapped file>'` out into\n  // individual exports (which nextjs seems to require), then delete the tempoary file.\n  let proxyCode = await rollupize(tempFilePath, this.resourcePath);\n  fs.unlinkSync(tempFilePath);\n\n  if (!proxyCode) {\n    // We will already have thrown a warning in `rollupize`, so no need to do it again here\n    return userCode;\n  }\n\n  // Add a query string onto all references to the wrapped file, so that webpack will consider it different from the\n  // non-query-stringged version (which we're already in the middle of loading as we speak), and load it separately from\n  // this. When the second load happens this loader will run again, but we'll be able to see the query string and will\n  // know to immediately return without processing. This avoids an infinite loop.\n  const resourceFilename = path.basename(this.resourcePath);\n  proxyCode = proxyCode.replace(\n    new RegExp(`/${escapeStringForRegex(resourceFilename)}'`, 'g'),\n    `/${resourceFilename}?__sentry_wrapped__'`,\n  );\n\n  return proxyCode;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;"}