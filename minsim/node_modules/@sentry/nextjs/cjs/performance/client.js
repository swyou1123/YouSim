Object.defineProperty(exports, '__esModule', { value: true });

var hub = require('@sentry/hub');
var utils = require('@sentry/utils');
var Router = require('next/router');

var global = utils.getGlobalObject();

/**
 * Every Next.js page (static and dynamic ones) comes with a script tag with the id "__NEXT_DATA__". This script tag
 * contains a JSON object with data that was either generated at build time for static pages (`getStaticProps`), or at
 * runtime with data fetchers like `getServerSideProps.`.
 *
 * We can use this information to:
 * - Always get the parameterized route we're in when loading a page.
 * - Send trace information (trace-id, baggage) from the server to the client.
 *
 * This function extracts this information.
 */
function extractNextDataTagInformation() {
  let nextData;
  // Let's be on the safe side and actually check first if there is really a __NEXT_DATA__ script tag on the page.
  // Theoretically this should always be the case though.
  var nextDataTag = global.document.getElementById('__NEXT_DATA__');
  if (nextDataTag && nextDataTag.innerHTML) {
    try {
      nextData = JSON.parse(nextDataTag.innerHTML);
    } catch (e) {
      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && utils.logger.warn('Could not extract __NEXT_DATA__');
    }
  }

  if (!nextData) {
    return {};
  }

  var nextDataTagInfo = {};

  const { page, query, props } = nextData;

  // `nextData.page` always contains the parameterized route - except for when an error occurs in a data fetching
  // function, then it is "/_error", but that isn't a problem since users know which route threw by looking at the
  // parent transaction
  nextDataTagInfo.route = page;
  nextDataTagInfo.params = query;

  if (props && props.pageProps) {
    if (props.pageProps._sentryBaggage) {
      nextDataTagInfo.baggage = props.pageProps._sentryBaggage;
    }

    if (props.pageProps._sentryTraceData) {
      nextDataTagInfo.traceParentData = utils.extractTraceparentData(props.pageProps._sentryTraceData);
    }
  }

  return nextDataTagInfo;
}

var DEFAULT_TAGS = {
  'routing.instrumentation': 'next-router',
} ;

let activeTransaction = undefined;
let startTransaction = undefined;

// We keep track of the previous page location so we can avoid creating transactions when navigating to the same page.
// This variable should always contain a pathname. (without query string or fragment)
// We are making a tradeoff by not starting transactions when just the query string changes. One could argue that we
// should in fact start transactions when the query changes, however, in some cases (for example when typing in a search
// box) the query might change multiple times a second, resulting in way too many transactions.
// Because we currently don't have a real way of preventing transactions to be created in this case (except for the
// shotgun approach `startTransactionOnLocationChange: false`), we won't start transactions when *just* the query changes.
let previousLocation = undefined;

// We keep track of the previous transaction name so we can set the `from` field on navigation transactions.
let prevTransactionName = undefined;

var client = hub.getCurrentHub().getClient();

/**
 * Creates routing instrumention for Next Router. Only supported for
 * client side routing. Works for Next >= 10.
 *
 * Leverages the SingletonRouter from the `next/router` to
 * generate pageload/navigation transactions and parameterize
 * transaction names.
 */
function nextRouterInstrumentation(
  startTransactionCb,
  startTransactionOnPageLoad = true,
  startTransactionOnLocationChange = true,
) {
  startTransaction = startTransactionCb;

  if (startTransactionOnPageLoad) {
    const { route, traceParentData, baggage, params } = extractNextDataTagInformation();

    prevTransactionName = route || global.location.pathname;
    previousLocation = global.location.pathname;

    var source = route ? 'route' : 'url';

    activeTransaction = startTransactionCb({
      name: prevTransactionName,
      op: 'pageload',
      tags: DEFAULT_TAGS,
      ...(params && client && client.getOptions().sendDefaultPii && { data: params }),
      ...traceParentData,
      metadata: {
        source,
        ...(baggage && { baggage: utils.parseBaggageHeader(baggage) }),
      },
    });
  }

  Router.default.ready(() => {
    // Spans that aren't attached to any transaction are lost; so if transactions aren't
    // created (besides potentially the onpageload transaction), no need to wrap the router.
    if (!startTransactionOnLocationChange) return;

    // `withRouter` uses `useRouter` underneath:
    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/with-router.tsx#L21
    // Router events also use the router:
    // https://github.com/vercel/next.js/blob/de42719619ae69fbd88e445100f15701f6e1e100/packages/next/client/router.ts#L92
    // `Router.changeState` handles the router state changes, so it may be enough to only wrap it
    // (instead of wrapping all of the Router's functions).
    var routerPrototype = Object.getPrototypeOf(Router.default.router);
    utils.fill(routerPrototype, 'changeState', changeStateWrapper);
  });
}

/**
 * Wraps Router.changeState()
 * https://github.com/vercel/next.js/blob/da97a18dafc7799e63aa7985adc95f213c2bf5f3/packages/next/next-server/lib/router/router.ts#L1204
 * Start a navigation transaction every time the router changes state.
 */
function changeStateWrapper(originalChangeStateWrapper) {
  return function wrapper(
    
    method,
    // The parameterized url, ex. posts/[id]/[comment]
    url,
    // The actual url, ex. posts/85/my-comment
    as,
    options,
    // At the moment there are no additional arguments (meaning the rest parameter is empty).
    // This is meant to protect from future additions to Next.js API, especially since this is an
    // internal API.
    ...args
  ) {
    var newTransactionName = utils.stripUrlQueryAndFragment(url);

    // do not start a transaction if it's from the same page
    if (startTransaction !== undefined && previousLocation !== as) {
      previousLocation = as;

      if (activeTransaction) {
        activeTransaction.finish();
      }

      var tags = {
        ...DEFAULT_TAGS,
        method,
        ...options,
      };

      if (prevTransactionName) {
        tags.from = prevTransactionName;
      }

      prevTransactionName = newTransactionName;
      activeTransaction = startTransaction({
        name: prevTransactionName,
        op: 'navigation',
        tags,
        metadata: { source: 'route' },
      });
    }
    return originalChangeStateWrapper.call(this, method, url, as, options, ...args);
  };
}

exports.nextRouterInstrumentation = nextRouterInstrumentation;
//# sourceMappingURL=client.js.map
